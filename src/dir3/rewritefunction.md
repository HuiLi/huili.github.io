# 重写器
重写器的主要功能是:
<br>1.视图重写<br>
处理视图是重写器主要的传统角色.对于在FROM子句中出现的每一个视图引用,重写器都会从目录管理器中检索出视图定义.然后重写查询,用这个视图所引用的表和谓词来替换这个视图,以及将任何对这个视图的引用替换为对这个视图中的表的列引用.这个过程是递归的,直到这个查询表达式里只有表、没有视图。这种视图重写技术，率先是INGERS为基于集合的QUEL语言提出 的，在SQL上需要一些额外手段去正确处理重复消除、嵌套查询、空值和一些其他棘手的细节。
<p>2.常量运算表达式<br>
查询重写可以简化常量运算表达式,例如,R.x<10+2+R.y被重写为R.X<12+R.Y。
<p>3.谓词逻辑重写<br>
逻辑重写是应用在基于WHERE子句中的谓词和常量的.简单的布尔逻辑往往是用来改进"表达式"和"基于索引的访问方法的能力"这二者之间的匹配程度.例如,一个诸如NOT Emp.Salary>100000的谓词,可能被重写为Emp.Salary<=100000。通过简单的满足性测试,这些逻辑重写甚至可能导致短路查询执行.例如,表达式Emp.salary<7500 AND Emp.salary>1000000,可以被FALSE替换。这就允许系统返回一个空的查询值,而无需访问数据库.不可满足的查询可能看起来令人难以置信,但是回想一下,谓词可以被"隐藏"在视图定义中,而且不被外部查询的作者知道.例如,上述的查询,可能由于在一个成为"高管"的视图上查询"工资收入较低的员工"而导致的.在Microsoft SQL Server并行安装中,不可满足的谓词也形成了"分区消除"的基础:当一个关系通过区间谓词被水平跨磁盘进行分区时,如果它的区间分区谓词和查询谓词的合取是不可能满足的,那么查询就没必要在一个卷上运行.另一个重要的逻辑重写使用谓词传递性来引入新的谓词.例如,R.x<10 AND R.x=S.y,暗示着额外添加了一个谓词"AND S.y<10"。增添这些传递谓词增加了优化器选择方案的能力,这些方案在执行的早期阶段就可以过滤数据,尤其是通过使用基于索引的访问方法.
<p>4.子查询扁平化和其他启发式重写<br>
在当代的商业数据库管理系统中,查询优化器是最复杂的组件之一.为了把这种复杂性控制在一定程度以内,大多数优化器都独立地优化单个SELECT-FROM-WHERE查询块，并不跨块优化。因此，许多系统把查询重写为一种更适合优化器的形式,而不是去想办法使优化器变得更加复杂.这种转变有时候也称为查询规范化.规范化的一种类型就是把语义等价查询重写为规范化的形式,尽量确保语义等价查询被优化后可以产生相同的查询计划.另一个重要的启发式方法就是扁平化嵌套查询,这样就可以最大程度地为查询优化器单块优化提供机会.由于重复语义、子查询、空值和相关性等问题，在SQL中的一些情况下,这将会是非常棘手的.在早期时候,子查询扁平化是一个纯粹的启发式重写,但是,现在一些产品已经将重写决策建立在代价分析基础之上.其他跨块查询的重写也是可能的.例如,谓词传递性允许谓词在子查询之间被复制.扁平化相关的子查询,对于在并行架构上实现良好的性能是尤其重要的:相关子查询会导致"嵌套循环"式的、查询块之间的比较,这将会序列化执行子查询,尽管有可用的并行资源.

